package wiki

import (
	"errors"
	"log" // Add log import for capturing logs during tests
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/rgehrsitz/AutoDoc/pkg/storage"
	// "github.com/rgehrsitz/AutoDoc/pkg/wiki/helpers" // Removed incorrect import
)

var ErrNotFound = errors.New("not found")

// MockStorage implements storage.Storage for testing
type MockStorage struct {
	docs     map[string]*storage.Document
	refs     map[string][]*storage.Reference
	backRefs map[string][]*storage.Reference
}

func NewMockStorage() *MockStorage {
	return &MockStorage{
		docs:     make(map[string]*storage.Document),
		refs:     make(map[string][]*storage.Reference),
		backRefs: make(map[string][]*storage.Reference),
	}
}

func (m *MockStorage) SaveDocument(doc *storage.Document) error {
	m.docs[doc.ID] = doc
	return nil
}

func (m *MockStorage) BatchSaveDocuments(docs []*storage.Document) error {
	for _, doc := range docs {
		m.docs[doc.ID] = doc
	}
	return nil
}

func (m *MockStorage) GetDocument(id string) (*storage.Document, error) {
	if doc, ok := m.docs[id]; ok {
		return doc, nil
	}
	return nil, ErrNotFound
}

func (m *MockStorage) ListDocuments(docType storage.DocumentType) ([]*storage.Document, error) {
	var docs []*storage.Document
	for _, doc := range m.docs {
		if doc.Type == docType {
			docs = append(docs, doc)
		}
	}
	return docs, nil
}

func (m *MockStorage) SaveReference(ref *storage.Reference) error {
	m.refs[ref.SourceID] = append(m.refs[ref.SourceID], ref)
	m.backRefs[ref.TargetID] = append(m.backRefs[ref.TargetID], ref)
	return nil
}

func (m *MockStorage) BatchSaveReferences(refs []*storage.Reference) error {
	for _, ref := range refs {
		if err := m.SaveReference(ref); err != nil {
			return err
		}
	}
	return nil
}

func (m *MockStorage) GetReferences(sourceID string) ([]*storage.Reference, error) {
	if refs, ok := m.refs[sourceID]; ok {
		return refs, nil
	}
	return nil, nil
}

func (m *MockStorage) GetBackReferences(targetID string) ([]*storage.Reference, error) {
	if refs, ok := m.backRefs[targetID]; ok {
		return refs, nil
	}
	return nil, nil
}

func (m *MockStorage) SearchSimilar(embedding []float64, limit int) ([]*storage.Document, error) {
	// For testing, just return all documents up to the limit
	var docs []*storage.Document
	for _, d := range m.docs {
		docs = append(docs, d)
		if len(docs) >= limit {
			break
		}
	}
	return docs, nil
}

func (m *MockStorage) Close() error {
	return nil
}

func TestGenerator(t *testing.T) {
	// Redirect log output to the test logger
	log.SetOutput(os.Stdout)

	// Create temp directory for output
	tmpDir, err := os.MkdirTemp("", "wiki-test")
	if err != nil {
		t.Fatalf("Failed to create temp directory: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create mock storage
	store := NewMockStorage()

	// Add test documents
	archDoc := &storage.Document{
		ID:        "arch1",
		Type:      storage.TypeArchitecture,
		Path:      "architecture.md",
		Content:   "# Architecture\n\nThis is the architecture overview.",
		UpdatedAt: time.Now(),
	}
	store.SaveDocument(archDoc)

	moduleDoc := &storage.Document{
		ID:        "mod1",
		Type:      storage.TypeModule,
		Path:      "pkg/example/example.go",
		Content:   "# Example Package\n\nThis is an example package.",
		UpdatedAt: time.Now(),
	}
	store.SaveDocument(moduleDoc)

	// Add test reference
	ref := &storage.Reference{
		SourceID: moduleDoc.ID,
		TargetID: archDoc.ID,
		Type:     "import", // Use string literal since we don't have access to the constant
	}
	store.SaveReference(ref)

	// Create generator
	gen := NewGenerator(store)

	// Create necessary template files in the expected location
	templateDir := filepath.Join("pkg", "wiki", "templates")
	if err := os.MkdirAll(templateDir, 0755); err != nil {
		t.Fatalf("Failed to create template directory: %v", err)
	}

	layoutPath := filepath.Join(templateDir, "layout.html")
	layoutContent := `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{{ .Title }}</title>
    <link rel="stylesheet" href="assets/style.css">
</head>
<body>
    <header>
        <h1>{{ .ProjectName }}</h1>
        <nav>
            {{ range .NavItems }}
                <a href="{{ .URL }}">{{ .Title }}</a>
            {{ end }}
        </nav>
    </header>
    <main>
        {{ .Content }}
    </main>
    <footer>
        <p>Generated by AutoDoc</p>
    </footer>
    <script src="assets/search.js"></script>
</body>
</html>`
	if err := os.WriteFile(layoutPath, []byte(layoutContent), 0644); err != nil {
		t.Fatalf("Failed to write layout.html: %v", err)
	}

	// Generate wiki
	cfg := Config{
		OutputDir:    tmpDir,
		ProjectName:  "Test Project",
		ProjectURL:   "https://example.com/test",
		Theme:        "light",
		CustomStyles: map[string]string{},
	}

	if err := gen.Generate(cfg); err != nil {
		t.Fatalf("Failed to generate wiki: %v", err)
	}

	// Check if files were generated
	files := []string{
		"index.html",
		"architecture.html",
		filepath.Join("pkg", "example", "example.go.html"),
		"search.html",
		"assets/style.css",
		"assets/search.js",
	}

	for _, file := range files {
		path := filepath.Join(tmpDir, file)
		if _, err := os.Stat(path); os.IsNotExist(err) {
			t.Errorf("Expected file %s was not generated", file)
		} else {
			log.Printf("Successfully generated file: %s", path)
		}
	}
}
